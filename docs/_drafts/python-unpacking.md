---
layout: post
title:  python 언패킹에 대해서
category: python
tags: unpacking list tuple
---


## 튜플 언패킹


시작은 아래와 같은 map 을 통한 리스트 데이터를 받는 문장을 list() 함수 사용하지 않고 언패킹을 이용할 수 있을까 하는 궁금증에서 시작했습니다.
```
a = list(map(int,input().split()))
```
리스트 요소의 개수가 3 이 확실하다면 아래와 같이 언패킹을 사용할 수 있습니다.
```
a,b,c = map(int,input().split())
```
만약 리스트의 길이를 미리 알 수 없는 경우라면 어떻게 하면 될까요? 아래와 같이 첫번째 데이터만 따로 추출하고 나머지는 하나로 모아서 받을 수 있습니다.
```
a,*b = map(int,input().split())
```
그럼 모두를 하나로 합쳐서 받을 수 없을까요? 그냥 *a 라고만 쓰면 안될까요?



## 에러!
그냥 `*a =...` 라고 쓸 경우
```
*a = map(int, input().split())
```

위 문장을 실행하면 다음과 같은 에러가 발생합니다.
```
SyntaxError: starred assignment target must be in a list or tuple
```

에러 메시지 자체는 명료해서 이래하는데 어려움이 없지만, 더 상세한 내용을 듣고 싶어서 Chat GPT 에 물어봤습니다. 얻은 답변을 요약하면 다음과 같습니다.

>
> Python에서는 ***(스타 언패킹 연산자)** 를 사용할 때, 반드시 리스트([]) 또는 튜플(()) 형태로 감싸야 합니다.
>
> 단독으로 *a = ...처럼 사용하는 것은 문법적으로 허용되지 않습니다.
>
> 에러 없이 실행하려면 리스트나 튜플로 감싸야 합니다.
>
> ```
> *a, = map(int, input().split())  # 콤마(,) 추가
> *a, = list(map(int, input().split()))  # 동일한 결과
> ```
>
> `*a, = ...` 처럼 뒤에 쉼표(,)를 추가하면 Python은 이를 **"튜플 언패킹"** 으로 인식하여 정상적으로 동작합니다.
>

위 내용은 ChatGPT 가 알려준 내용을 정리한 것인데요, 위 내용 중 약간 거슬리는 부분이 있습니다.

`*a, = ...`

**튜플 언패킹** 이란 용어는 마치 a 가 튜플로 저장되는 것 처럼 오인하게 만드는 안좋은 표현입니다. 대입 연산자 `=` 의 우측에서 일어나는 현상을 **언패킹** 이라고 표현하는 것은 문제 없습니다.


python 에서 언패킹을 할 수 있는 대상은 시퀀스 유형입니다. 그 중에서 튜플, 리스트와 같은 시퀀스 형의 언패킹은 기본 시퀀스 언패킹 이라고 하는데요, 언패킹 해서 저장할 변수를 나열할 때 쉼표를 사용합니다.

```
# Python의 기본 시퀀스 언패킹 문법
x, y = (1, 2)  # 튜플 언패킹
x, y = [1, 2]  # 리스트 언패킹
```

일반적으로 쉼표 (,) 가 있으면 Python은 튜플 언패킹을 수행한다고 해석하는 경우가 많지만,
엄밀히 말하면 "튜플 언패킹" 이라는 표현은 적절하지 않을 수 있습니다.

쉼표(,)가 있으므로 Python의 일반적인 문법에서는 "튜플 언패킹" 처럼 보이지만, 보다 일반적으로는 **시퀀스 언패킹** 이라고 표현해야 합니다. 언패킹 대상이 튜플이면 "튜플 언패킹", 리스트이면 "리스트 언패킹" 이라고 할 수 있습니다.

지금의 문제는 언패킹 된 데이터를 저장할 때, * (스타) 를 이용한 독특한 저장이 어떻게 해석되고 동작 되는지에 대한 것입니다.

표현의 정확성이야 어쨌든 간에, 정리를 하자면 "*a 와 같은 변수로 대입을 하면 우측의 나머지 모든 항목을 다 받아서 리스트로 만들어 a 에 저장한다" 입니다.


## 추가 질문

### `*a, = ...` 와 같이 사용할 때, a 는 항상 리스트로만 저장될까요?

이 질문의 의도는, 묶음 데이터를 저장할 수 있는 데이터 유형에는 꼭 리스트만 있는 것이 아닌데도 그런가? 입니다.

정답은 YES 입니다. `*a, = ...` 형태로 사용하면 a 는 항상 리스트(list)로 저장됩니다. 아래 코드를 보시죠.

```
*a, = [1, 2, 3]
print(a)        # [1, 2, 3]
print(type(a))  # <class 'list'>
```
리스트를 언패킹 했으니까 리스트로 저장되는 것 아닌가? 하고 생각할 수도 있겠습니다만..

```
*a, = (4, 5, 6)
print(a)        # [4, 5, 6]
print(type(a))  # <class 'list'>

*a, = 7, 8, 9
print(a)        # [7, 8, 9]
print(type(a))  # <class 'list'>
```
위 예를 보면, 튜플 언패킹을 해서 저장했음에도 모두 리스트로 저장이 됩니다! 모든 경우에서 a 는 튜플이 아니라 리스트(list)로 저장됩니다.

<br>

공식 Python 문서에서 그 내용을 확인할 수 있습니다. <br>
<https://docs.python.org/ko/3.13/reference/simple_stmts.html> <br>
>
> 7. 단순문(Simple statements) <br>
>
> ... 이터러블의 처음 항목들은, 왼쪽에서 오른쪽으로, 스타드 타깃 앞에 나오는 타깃들에 대입됩니다. 이터러블의 마지막 항목들은 스타드 타깃 뒤에 나오는 타깃들에 대입됩니다. 이터러블의 나머지 항목들로 구성된 리스트가 스타드 타깃에 대입됩니다 (이 리스트는 비어있을 수 있습니다).
>

규격에서는 starred target 이라고 표현을 하고 있군요.

PEP 3132: Extended Iterable Unpacking 문서도 참고할 만 합니다. <ㅠr>
<https://peps.python.org/pep-3132/>

<br>

정리하자면, 튜플을 언패킹하든 리스트를 언패킹하든, (대입 = 의 좌측에 있는) 저장될 변수 목록에 있는 *a 의 값은 항상 리스트 타입의 데이터 입니다.

물론, 튜플을 원한다면 직접 변환하면 됩니다만, 굳이 그래야만 하는 경우는 별로 없을 것 같습니다.
```
*a, = (1, 2, 3, 4)
a = tuple(a)    # 튜플로 명시적으로 변환할 수 있음.
print(a)        # (1, 2, 3, 4)
print(type(a))  # <class 'tuple'>
```

### 생각해 볼 점

이 스타를 이용한 대입을 사용하면, 아주 깔끔하게 코드를 유지 관리할 수 있다는 장점이 있지만, 성능 면에서는 약간의 손해가 있어서 특정 어플리케이션에서는 적합하지 않을 수 있다는 점도 알고 있으면 좋겠습니다.

<https://neurowinter.com/python/2021/11/21/starred-expressions/>



