---
layout: post
title:  python 의 subscription 연산자
category: python
tags: jekyll
---

# 서브스크립션 연산

배열의 원소에 접근할 때 사용하는 각괄호 연산자 `[]` 에 대한 내용입니다.

두괄식으로 요약 정리를 하면:

- `[ ]` 연산자는 `__getitem__()` 을 호출하는 것과 동일함.
- `__getitem__` 은 사용자가 overriding 할 수 있음.
- 인자에 '표현식 리스트'가 전달 될 수 있음. 각 표현식을 구분할 때에는 콤마를 사용함.
- 표현식은 슬라이싱을 포함할 수도 있음.
- ...



<br>

---
<br>
아래는 python 공식 레퍼런스 문서의 내용을 그대로 번역한 것입니다.

---
### 6.3.2. 서브스크립션 (Subscriptions)
컨테이너 클래스 인스턴스의 구독(서브스크립션)은 일반적으로 컨테이너에서 요소를 선택합니다. 제네릭 클래스의 구독은 일반적으로 GenericAlias 객체를 반환합니다.

```
subscription ::= primary "[" flexible_expression_list "]"
```

객체가 구독되면 (subscripted), 인터프리터는 프라이머리와 표현식 목록을 평가합니다.

프라이머리는 구독을 지원하는 객체에 대해 평가해야 합니다. 객체는 `__getitem__()` 및 `__class_getitem__()` 중 하나 또는 둘 모두를 정의하여 구독을 지원할 수 있습니다. 프라이머리가 구독되면 표현식 목록의 평가된 결과가 이러한 메서드 중 하나로 전달됩니다. `__getitem__` 대신 `__class_getitem__` 이 호출되는 경우에 대한 자세한 내용은 "(3.3.5.2) __class_getitem__ vs __getitem__" 을 참조하세요.


표현식 목록에 쉼표가 하나 이상 포함되어 있거나, 표현식에 별표가 있는 경우, 표현식 목록은 표현식 목록의 항목들로 구성된 "튜플"로 평가됩니다. 그렇지 않으면 표현식 목록은 목록의 유일한 멤버의 값으로 평가됩니다.

- 버전 3.11에서 변경: 표현식 목록의 표현식은 별표로 표시될 수 있습니다. See PEP 646.

빌트인 개체의 경우, `__getitem__()` 을 통해 구독을 지원하는 개체에는 두 가지 유형이 있습니다:

1. 매핑<br>
프라이머리가 매핑인 경우, 표현식 목록은 값이 매핑의 키 중 하나인 개체(object)로 평가되어야 하며, 구독은 해당 키에 해당하는 매핑의 값을 선택합니다. 빌트인 매핑 클래스의 예는 딕셔너리 클래스입니다.

2. 시퀀스<br>
프라이머리가 시퀀스인 경우, 표현식 목록은 int 또는 슬라이스로 평가되어야 합니다. (다음 섹션에서 설명 참조). 빌트인 시퀀스 클래스의 예로는 str, list, 튜플 클래스가 있습니다.

형식적인 구문에서는 시퀀스의 음수 인덱스에 대한 특별한 규정이 없습니다. 그러나 내장된 시퀀스는 모두 인덱스에 시퀀스의 길이를 더하여 음수 인덱스를 해석하는 `__getitem__()` 메서드를 제공하므로, `x[-1]` 은 `x` 의 마지막 항목을 선택합니다. 결과 값은 시퀀스의 항목 수보다 작은 음수가 아닌 정수여야 하며, 구독은 해당 값(0부터 카운트)을 인덱스로 하는 항목을 선택합니다. 음수 인덱스 및 슬라이싱 지원은 객체의 `__getitem__()` 메서드에서 이루어지므로 이 메서드를 재정의하는 서브클래스는 해당 지원을 명시적으로 추가해야 합니다.

문자열은 항목이 문자인 특수한 종류의 시퀀스입니다. 문자는 별도의 데이터 유형이 아니라 정확히 한 문자로 이루어진 문자열입니다.

---
정리를 하자면..
- 서브스크립트 연산자로 꼭 정수만 사용할 수 있는 것은 아니다.
- `__get_item__` 메소드가 지원하기만 한다면 어떠한 데이터도 전달 할 수 있다. 문자열을 받을 수 있다면 마치 dict 처럼 동작시킬 수도 있다.
- `obj[3,5]` 는 `obj.__getitem__((3,5))` 와 동일하다. 이때 `(3,5)` 는 튜플이다.
- 배열의 배열로 구현한 2차원 배열이었다면 `obj[3,5]`는 `obj[3][5]`와 동일하게 처리하는 것이 인간 관점에선 자연스럽다. 하지만 이렇게 구현해야 한다는 규칙은 없으니 `obj`를 구현한 사람 마음대로이다.



---
<br>

다음은 궁금증 해결을 위해 챗봇과 대화한 내용을 요약 정리한 것입니다.

## 질문

아래 코드 중에서, x_data, t_data 추출에 사용되는 [ ] 동작이 잘 이해 안됩니다.

```python
import numpy as np
loaded_data = np.loadtxt('/path/to/csv', delimiter=',')

x_data = loaded_data[ :, 0: -1]
t_data = loaded_data[ :, [-1] ]
```

콜론을 사용하였으니 슬라이싱 같기도 한데, 콤마가 사용되거나 리스트를 전달하고 있습니다. 이 부분에 대해 설명을 해 주세요.

## 답변

코드에서 `loaded_data[ :, 0:-1]와 loaded_data[:, [-1]]` 의 동작을 하나씩 살펴볼게요.


### ✅ NumPy의 인덱싱 & 슬라이싱 개념 정리
NumPy 에서 배열의 특정 부분을 선택하는 방법은 크게 3가지입니다.

- 1️⃣ 정수 인덱싱 → 특정 원소 선택 (`A[1, 2]`)
- 2️⃣ 슬라이싱(Slicing) → 연속된 부분 선택 (`A[:, 1:3]`)
- 3️⃣ 리스트/배열 인덱싱 → 특정 열 또는 행을 유지 (`A[:, [1, 3]]`)


### ✅ 코드 분석
```
x_data = loaded_data[:, 0:-1]
t_data = loaded_data[:, [-1]]
```
- 📌 `loaded_data` 는 CSV에서 로드된 2D NumPy 배열 (행렬)이라고 가정합니다.
- 📌 `:`은 모든 행을 의미합니다.
- 📌 `0:-1` 과 `[-1]` 부분이 핵심입니다.


#### 1️⃣ `x_data = loaded_data[:, 0:-1]`

💡 의미:
- `0:-1` → 첫 번째 열(인덱스 0)부터 마지막 이전 열(인덱스 -1 제외)까지 선택
- `:` → 모든 행 유지

✔ 결과: 마지막 열을 제외한 모든 열이 포함된 2D 배열

```python
A = np.array([[1, 2, 3],
              [4, 5, 6]])

print(A[:, 0:-1])
# [[1 2]
#  [4 5]]
```
✔ -1은 **마지막 열**을 의미하므로, `0:-1` 은 **마지막 열을 제외한 모든 열**을 선택

---
<br>
#### 2️⃣ t_data = loaded_data[:, [-1]]
💡 의미:
- `[-1]` → 마지막 열을 유지하면서 선택 (2D 형태 유지)
- `:` → 모든 행 유지

✔ 결과: 마지막 열만 포함된 2D 배열

```python
print(A[:, [-1]])
# [[3]
#  [6]]
```

🚀 여기서 중요한 점!

- `[:, -1]` (대괄호 없음) → 결과는 1D 배열 (n,)
- `[:, [-1]]` (대괄호 포함) → 결과는 2D 배열 (n,1)

✔ `t_data` 는 2D 형태를 유지해야 하므로 `[-1]` 을 사용하여 열을 유지

### 🎯 정리

| 표현 | 결과 형태 | 설명 |
| --- | --- | --- |
| A[:, 0:-1] | (n, m-1) | 마지막 열을 제외한 모든 열 |
| A[:, -1] | (n,) | 마지막 열 (1D 배열) |
| A[:, [-1]] | (n,1) | 마지막 열을 2D 배열로 유지 |
<br>

✔ 마지막 열을 가져오면서 2D 형태로 유지하려면 `[:, [-1]]` 을 사용해야 합니다! 🚀

---
<br>

## 질문

파이썬의 문법(grammay) 관점에서 볼 때, 위와 같은 "[ .. , .. ]" 도 슬라이싱에 해당되나요? 이러한 것은 파이선 공식 문서 (언어 레퍼런스 또는 라이브러리 레퍼런스) 어디에 설명되어 있나요? 출처 링크를 제공해 주세요.


## 답변

### ✅ "[ .. , .. ]"는 슬라이싱(slicing)인가?

- `A[:, 0:-1]` 같은 표현은 슬라이싱(slicing) 에 해당합니다.
- 하지만 `A[:, [-1]]` 같은 표현은 "고급(advanced) 인덱싱" 입니다.
- `[-1]` 처럼 **리스트를 사용하면 슬라이싱이 아니라 배열 인덱싱(advanced indexing)** 으로 동작합니다.

즉,
- ✔ `A[:, 0:-1]` → 슬라이싱 (기본 인덱싱)
- ✔ `A[:, [-1]]` → 고급 인덱싱 (리스트 기반 인덱싱)


### ✅ 파이썬 문법적으로 `[...]`는 무엇인가?

파이썬 문법(Grammar)에서 `[...]`는 "subscription (구독)" 연산에 해당합니다.

- 문법적으로 `A[x]` 는 `A.__getitem__(x)` 와 동일합니다.
- 따라서, `A[:, [-1]]` 같은 표현은 NumPy 배열의 `__getitem__` 이 어떻게 동작하는지에 따라 결정됩니다.

#### 📌 공식 문서 📖

파이썬 언어 레퍼런스

- 파이썬 공식 문서: Subscription (구독 연산)
- 관련 문법: `A[x]` → `A.__getitem__(x)`
- 예제:

``` python
class MyClass:
    def __getitem__(self, key):
        return f"Getting item {key}"

obj = MyClass()
print(obj[1])      # Getting item 1
print(obj[1:3])    # Getting item slice(1, 3, None)
print(obj[:, 0])   # Getting item (slice(None, None, None), 0)
```

NumPy 공식 문서

- NumPy: Indexing documentation
- 여기에서 **Advanced Indexing** 과 **Basic Slicing** 이 구분됨


### ✅ 슬라이싱 vs 고급 인덱싱의 차이

| 표현 | 동작 방식 | 결과 |
| --- | --- | --- |
| A[1, 2] | 기본 인덱싱 | 단일 값 (스칼라) |
| A[:, 1:3] | 슬라이싱 (기본 인덱싱) | 2D 배열 |
| A[:, [1, 3]] | 고급 인덱싱 (리스트 사용) | 2D 배열 |
<br>

- ✔ 슬라이싱(:)은 항상 연속된 범위를 반환
- ✔ 리스트([...])를 사용하면 고급 인덱싱으로 변환되어 독립적인 열/행을 선택할 수 있음

### 🎯 결론

- `[...]` 는 파이썬 문법적으로 "Subscription (구독 연산)"에 해당하며 `__getitem__()` 을 호출하는 것과 동일
- `:` 을 사용하면 슬라이싱(slicing)
- 리스트(`[...]`)를 사용하면 "고급 인덱싱(Advanced Indexing)"
- 공식 문서는 파이썬 언어 레퍼런스(Subscription 문법) 및 NumPy 의 Indexing 문서에서 확인 가능

🚀 즉, `A[:, [-1]]` 은 문법적으로 **고급 인덱싱** 이므로, NumPy의 동작 규칙에 따라 처리되는 것입니다!

---







